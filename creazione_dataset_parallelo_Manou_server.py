# -*- coding: utf-8 -*-
"""creazione_dataset_parallelo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Oh4E3cKqmZ-Ci2mzfqx1N698X-htCmV

Serve per controllare la versione di PyTorch presente in google colab.

Se la versione di Pytorch non è la 1.8.1 andare sul sito di pytorch geometric e modificare il blocco di codice in cui viene installato pytorch_geometric.

Andare su https://github.com/rusty1s/pytorch_geometric e prendere i comandi per installare la versione di pytoch geometric combatibile con il pytorch presente.
"""

""" Changed version due to removing start and end event prefixes!"""

#! nvcc --version

#!pip install torch

import torch
import config
import os
args=config.load()

#print(torch.__version__)

"""Codice per installare le librerie librerie di pytorch geometric su colab"""
"""
! pip install torch-scatter 
! pip install torch-sparse 
! pip install torch-cluster 
! pip install torch-spline-conv
! pip install torch-geometric
"""
"""Metodo per la creazione dei grafi nel formato della libreria networkx.

Alla fine viene creato un file che contiene il nome delle varie tipologie di activity presenti nel dataset.

Il file verrà salvato in una cartella nel Drive Google chiamata dataset che deve essere precedentemente creata
"""

import networkx as nx
import string
file_name = "complete"#"completeHelpdesk"
#CHANGED!!!
file_id="0"

#prende ogni grafo e lo salva come inverso solo se sono falsi tutti i controlli if
def create_graph():
    ListGraph=[]
    # input = open(PATH+"/andreaa_bpi12w.g", "r")       #apro il file
    # input = open(PATH+"/andrea_bpi12full.g", "r")       #apro il file
    
    #CHANGED!!!
    input=open(PATH+"/"+file_id+".g", "r") 
    ids=[]
    for lines in input.readlines():                                                 #ciclo per la lettura del file riga per riga
        line = lines.split() 
        if not line:
            pass
        
        elif line[0]=="v":
            ids.append(line[4]) #cosa vuole prendere di preciso qui? MR
            
    input = open(PATH+"/"+file_name+".g", "r")       #apro il file
    
    attributes = []  
    bus=[]
    plants=[]
    items=[]
    vendors=[]
    matnrs=[]
   
                                                                     #creo una lista vuota per salvare le activity da andare a scrivere nel file
    #attrib2nd = []
    s=0
    for lines in input.readlines():                                                 #ciclo per la lettura del file riga per riga
        line = lines.split()                                                        #divide la riga in una lista di parole
        #si entra solo alla fine di un grafo
        if not line:                                                                #se vero fine lettura di un grafo 
            if nx.number_of_isolates(G) !=0: 
                #print('error line {}'.format(line)) #controllo che il grafo non contiene nodi isolati
                pass                                                                #istruzione nulla
            elif len(nx.get_node_attributes(G, "attribute"))!=len(G.nodes()):       #cotrollo che non ci siano nodi senza attributo
                #print('error line {}'.format(line))
                pass
            elif nx.number_connected_components(G.to_undirected()) !=1:             #controllo che ci sia una sola componenti connesse
                #print('error line {}'.format(line))
                pass
            elif len(G.nodes())<3:                                                  #controllo che se il grafo ha almeno tre nodi
                #print('error line {}'.format(line))
                pass
            else:
                ListGraph.append(G.reverse())                                       #salvo il grafo con gli archi invertiti         

 
        elif line[0]=="XP":                                                         #se vero creo un nuovo grafo vuoto
            
            G = nx.DiGraph()
        elif line[0]=="v":                                                          #se vero aggiungo un nodo e la sua informazione al grafo
            #*********************************************************<--> INTERVIENI QUI PER + ATTRIB, NO RIUSCITO PENSARE SOLUZIONE DINAMICA

            # print(line[3:73][1])
            # print(type(line[3:73][1]))
            # print(line[74])
            # print(type(line[74]))

            # <HARDCODED>
            G.add_node(int(float(line[1])-1),       #node nr
                       attribute = line[2],         #activity
                       attrib3 = float(line[3]),    #time features     #73..
                       attrib4 = float(line[4]),
                       attrib5 = float(line[5]),
                       ttmotif= float(line[6]),
                       polines=float(line[7]),
                       #nrchanges=float(line[8]),
                       #deltapodd=float(line[9]),
                       bu=line[8],
                       plant=line[9],
                       item=line[10],
                       vendor=line[11],
                       matnrshort=line[12],
                       target= float(line[13]), #added the target here!     \\\Viene preso il dtl\\
                       idn=ids[s] #concept:name - idname?
                       )
            s+=1
            # <\HARDCODED>
        elif line[0]=="e":                                                          #se vero aggiungo un arco al grafo
            G.add_edge(int(float(line[1])-1),int(float(line[2])-1))
    
    ListGraph.append(G.reverse()) #added this to also append the last graph!! because graph is only appended at the end.
    input.close()
    '''
    La utilizzo solo per salvarmi tutti gli attributi categorici per fare il hoe finale?
    '''
    #I DON'T THINK I NEED THIS PART, BECAUSE IT'S USED FOR OUTPUT
    for G in ListGraph:                                                             #crea lista attributi nodi (univoci)--> serve per qualunque attributo categorico
        for node in G.nodes:
            if G.nodes[node]['attribute'] not in attributes:
                attributes.append(G.nodes[node]['attribute'])
            if G.nodes[node]['bu'] not in bus:
                bus.append(G.nodes[node]['bu'])
            if G.nodes[node]['plant'] not in plants:
                plants.append(G.nodes[node]['plant'])
            if G.nodes[node]['item'] not in items:
                items.append(G.nodes[node]['item'])
            if G.nodes[node]['vendor'] not in vendors:
                vendors.append(G.nodes[node]['vendor'])
            if G.nodes[node]['matnrshort'] not in matnrs:
                matnrs.append(G.nodes[node]['matnrshort'])
            # if G.nodes[node]['attrib2nd'] not in attrib2nd:
            #     attrib2nd.append(G.nodes[node]['attrib2nd'])
    
    

    output = open(PATH+"/attributi.txt", "w")              #apro e creo il file per salvare gli attributi
    # output = open(PATH+"/attributi_new.txt", "w")              #apro e creo il file per salvare gli attributi
    for att in attributes:
        output.write(att+"\n")
    output.close()
    
    featurelist=[bus,plants,items,vendors,matnrs]
    featurenames=['bu','plant','item','vendor','matnrshort']
    for c in range(len(featurenames)):
        outputc=open(PATH+"/{}.txt".format(featurenames[c]), "w")
        for v in featurelist[c]:
            outputc.write(v+"\n")
        outputc.close()
    """
    output = open(PATH+"/attrib2nd.txt", "w")              #apro e creo il file per salvare gli attributi
    # output = open(PATH+"/attributi_new.txt", "w")              #apro e creo il file per salvare gli attributi
    for att in attrib2nd:
        output.write(att+"\n")
    output.close()
    """
    # print("lista grafi")
    # print(ListGraph)
    return ListGraph                                                                #ritorno la lista dei grafi

"""**TARGET**:
* Controllare archi uscenti dal sottografo -> nodi collegati (*esterni al sottografo*)
* Per ogni nodo trovato -> verificare disponibilità tutti archi entranti (*devono già appartenere al sottografo i nodi all'altra estremità*)
"""
#NOT NEED IT
#need something similar to map time value for the right node/event.
#add the target to the complete.g file!

### NEXT ACTIVITY _MR_ #######
def define_target(graph,subgraph):    #qui toccherà giocarci quando vorremo estendere la caraterizzazione del nodo predetto in output 
  
    reverse=graph.reverse()                                                         # inverte le direzioni degli archi del grafo direzionato (completo)
    possible_targets=[]                                                             # lista che conterrà i neighbors dei nodi del sottografo
    subgraph_nodes=list(subgraph.nodes())                                           #lista dei nodi del sottografo
    for node in subgraph_nodes:                                                     # per ogni nodo del sottografo, individua i neighbros e li inserisce in una lista
      possible_targets.extend(list(reverse.neighbors(node))) 
    possible_targets=list(set(possible_targets) - set(subgraph_nodes)) 

    target=possible_targets.copy() 
    for node in possible_targets:                                                   # per ogni possibile nodo target accerta che l'altro estremo degli archi entranti sia già un nodo del sottografo, altrimenti lo elimina dai target
      for node_from,node_to in reverse.in_edges(node):
        if node_from not in subgraph_nodes:
          target.remove(node_to)
          break
  
    new_t=''
    for i in range(0,len(target)):                                                  # sostituisce ogni nodo della lista target con la corrispettiva activity (attributo)
      targ_attr=graph.nodes[target[i]]['attribute']
      new_t=new_t+str(targ_attr)+' '
    target=new_t[:-1]   

    return target

"""Metodo per la creazione dei sottografi nel formato di networkx, a partire dai grafi precedentemente creati.

Alla fine viene creato un file che contiene il nome delle varie tipologie di activity presenti nel dataset come activity da predirre.

Il file è salvato nel Drive google nella cartella dataset che deve essere creata precedentemente
"""

#import networkx as nx

def create_sub_graph():
    
    ListGraph = create_graph()
    target_std=[]                                                                #creo una lista vuota per salvare le activity da predirre
    target_par=[]                                                                #creo una lista vuota per salvare le activity parallele predicibili


    ListSubGraph=[]                                                               #creo una lista vuota da popolare con i sottografi creati
    for graph in ListGraph:                                                       #ciclo per scorrere i grafi                                                     
        # print("graph")
        # print(graph)
        SubGraph = nx.Graph(target_std="no", target_par='no')                     #crea sottografo con attributi target_std e target_par inizializzati a "no"
        for node in list(graph.nodes()):                                          #scorro i nodi del grafo corrente
          #si entra solo dopo i primi due nodi perchè sempre in input (mai predetti)
            if len(SubGraph.nodes())>1: #changed min prefix length       
                #changed the next line                                    #controllo se il sottgrafo che si sta creando ha almeno due nodi all'interno


##INSERIMENTO DEL TARGET FEATURE //DTL

##INSERIMENTO DEL ACTIVITY DA PREDIRRE

                target_t1 = graph.nodes[node]['target']
                SubGraph.graph['target_std']= graph.nodes[node]['target'] #put the target value there for the correct node.     #assegna come target_std al sottografo il nodo corrente
                nodevar=node
                #if SubGraph.graph['target_std'] not in target_std:                #inserisce l'activity solo se non è già inserita nella lista target_std
                 #   target_std.append(SubGraph.graph['target_std'])
                # *********************************************
                #NOT NEEDED! IT SHOULDN'T USE THIS IN TRAINING

                target_par_tmp = define_target(graph.copy(),SubGraph)
                SubGraph.graph['target_par']= define_target(graph.copy(),SubGraph)  #assegna come target_par al sottografo il nodo corrente          
                
                #CHANGED!!!
                SubGraph.graph['caseid']=graph.nodes[node]['idn']
                if SubGraph.graph['target_par'] not in target_par:                #inserisce l'activity solo se non è già inserita nella lista target_par
                    target_par.append(SubGraph.graph['target_par'])

                ListSubGraph.append(SubGraph.copy().to_undirected())              #NOTA: la rete lavora sui grafo non diretti(questa cosa è modificabile in teoria)
                # if graph.nodes[node]['attribute']!="END":
                #     ListSubGraph.append(SubGraph.copy().to_undirected())
                #bij mij wordt er wel een voorspelling gemaakt bij de laatste prefix, bij next activity is dat tot de een na laatste
          # <HARDCODED>
            SubGraph.add_node(node, 
                              attribute=graph.nodes[node]['attribute'],
                              #attrib2=graph.nodes[node]['attrib2'],
                              attrib3=graph.nodes[node]['attrib3'],
                              attrib4=graph.nodes[node]['attrib4'],
                              attrib5=graph.nodes[node]['attrib5'],
                              ttmotif=graph.nodes[node]['ttmotif'],
                              polines=graph.nodes[node]['polines'],
                              #nrchanges=graph.nodes[node]['nrchanges'],
                              #deltapodd=graph.nodes[node]['deltapodd'],
                              bu=graph.nodes[node]['bu'],
                              plant=graph.nodes[node]['plant'],
                              item=graph.nodes[node]['item'],
                              vendor=graph.nodes[node]['vendor'],
                              matnrshort=graph.nodes[node]['matnrshort']
                              
                              )     #aggiungo un nuovo nodo al sottografo
          
            
            # <HARDCODED>
            for neig in graph.neighbors(node):                                    #aggiungo gli archi per quel nodo al sottografo
                SubGraph.add_edge(neig,node)
         
            #add last predicted value     do i need this??   
        #CHANGED!!! do i still need this? NO BECAUSE THIS ADDS THE END NODE
        # SubGraph.graph['caseid']= graph.nodes[nodevar]['idn']
        # SubGraph.graph['target_std']= graph.nodes[nodevar]['target']
        # SubGraph.graph['target_par']= "END"
        # ListSubGraph.append(SubGraph.copy().to_undirected())


    output = open(PATH+"/target_std.txt", "w")  #apro e scrivo le activity da predire sul file
    # output = open(PATH+"/target_std_new.txt", "w")  #apro e scrivo le activity da predire sul file
    
    for item in target_std:                                                           #scrive lista target sul file
        output.write(item+'\n')
    output.write("END\n")
    output.close()

    #NOT NEEDED
    output = open(PATH+"/target_par.txt", "w")  #apro e scrivo le activity da predire sul file
    # output = open(PATH+"/target_par_new.txt", "w")  #apro e scrivo le activity da predire sul file
    
    for item in target_par:                                                           #scrive lista target sul file
        output.write(item+'\n')
    output.write("END\n")
    output.close()

    return ListSubGraph

"""Dal file attributi.txt creato precedentemente si crea un dizionario delle activity che contiene per ogni activity il one hot vector corrispondente"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder

#onehot encoding for the activities
def dictattr(PATH,file):#="attributi.txt"):
    attr=[]
    input = open(PATH+"/"+file, "r")
    # input = open(PATH+"/attributi_new.txt", "r")
    for lines in input.readlines():
        lines = lines[:-1]
        attr.append(lines)          #ricrea la lista degli attributi
    input.close()
    s1 =pd.Series(attr)             #crea una serie come valori le attività
    s2=pd.get_dummies(s1)           #crea dataframe con tante colonne quante le attività e valori solo 0 e 1
    onedictfeat={}
    s3= s2.to_dict()                #crea dizionario: chiave=chiave dataframe, valore = dizionario (chiave=colonna dataframe, valore=0 o 1)
    for a,b in s3.items():
        onedictfeat[a]=list(b.values()) #nuovo dizionario (valore=lista valori con stessa chiave)
    # print("onedictfeat",onedictfeat)
    return onedictfeat

"""Dal file target.txt creato in precedenza si crea un dizionario con il valore di predizione assegnato ad ogni activity da predirre"""

#dizionario: chiave=target, valore=indice progressivo (da 0) 
#NOT NEEDED, just used to determine nr of neurons in output layer.
def dictarget():
    target_std={}
    i=0
    input = open(PATH+"/target_std.txt", "r")
    # input = open(PATH+"/target_std_new.txt", "r")
    for lines in input.readlines():
        lines = lines[:-1]
        target_std[lines]=i
        i=i+1
    input.close()
    #print('target std',target_std)

    target_par={}
    i=0
    input = open(PATH+"/target_par.txt", "r")
    # input = open(PATH+"/target_par_new.txt", "r")
    for lines in input.readlines():
        lines = lines[:-1]
        target_par[lines]=i
        i=i+1
    input.close()
    #print('target par',target_par)
    return target_std,target_par

"""classe Pytorch per la creazione o lettura del dataset per allenare la rete.

il file che contiene il dataset sarà creato all'interno della cartella process, questa certela viene creata all'interno della cartella dataset precedentemente creata nel drive. Il nome del file creato sarà quello passato dal metodo processed_file_names della classe.

Quando la classe viene richiamata prima controlla se all'interno della cartella process è presente il file con il nome passato nel metodo processed_file_names, se presente andrà a leggere il file, se non presente andrà ad attivare il metodo process per la creazione di un nuovo dataset e gli darà il nome passato tramite il metodo processed_file_names.

In questo script viene utilizzato per la creazione del dataset, si consiglia di controllare che non siano presenti all'interno della cartella process dataset con il nome inserito all'interno del metodo processed_file_names. 

Per creare il dataset completo nel metodo process mettere listGraph = create_sub_graph()

Per creare il dataset con undersamplig nel metodo process mettere listGraph=undersamplig(create_sub_graph(), n) -> sostituire n con il numero di elementi da prendere per ogni tipologia di activity da predirre
"""

import matplotlib.pyplot as plt

def draw(G):
    pos=nx.circular_layout(G)
    plt.figure(figsize=(7,5))
    nodes = nx.draw_networkx_nodes(G, pos,node_size=250)
    node_labels=nx.get_node_attributes(G, 'attribute')
    labels = nx.draw_networkx_labels(G, pos,labels=node_labels)
    edges = nx.draw_networkx_edges(G, pos) 
 
    plt.axis('off')
    plt.show()

import torch
import numpy as np
#import networkx as nx
from torch_geometric.data import InMemoryDataset, Data
 
 
class TraceDataset(InMemoryDataset):
 
    def __init__(self,  transform=None, pre_transform=None):
        super(TraceDataset, self).__init__('./dataset', transform, pre_transform)
        self.data, self.slices = torch.load(self.processed_paths[0])
 
 
 
    @property
    def processed_file_names(self):
        # return ['andreaa_bpi12w_par.pt']
         return [file_name+'_par.pt']
 
 
 
    def process(self):
        listGraph=create_sub_graph()    #a subgraph for each trace?          #vedi commento 366                                 #ritorna lista dei sottografi
        
        data_list = []
        attr = dictattr(PATH='./dataset',file="attributi.txt")
        bur= dictattr(PATH='./dataset',file="bu.txt")      
        plantr=dictattr(PATH='./dataset',file="plant.txt")   
        itemr=dictattr(PATH='./dataset',file="item.txt")  
        vendorr=dictattr(PATH='./dataset',file="vendor.txt")  
        matnrshortr=dictattr(PATH='./dataset',file="matnrshort.txt")  
                                                          #ritorna dizionario di liste (one hot)
        #attr2nd = dictattr(PATH='/content/drive/MyDrive/dataset/',file="attrib2nd.txt")                                                         #ritorna dizionario di liste (one hot)
        #print(attr2nd)
        target_std,target_par = dictarget()                                       #ritorna dizionari target_std e target_par con codice progressivo
        # print("listgraph")
        # print(listGraph)
        for G in listGraph:                                                       #ciclo per scorrere i sottografi
            x1 = []
            list_targ_par=[]
 
            # draw(G)
            for i in G.nodes:                                                     #ciclo che scorre i nodi **** altro punto in cui lavorare
                
                """
                x1.append([*attr[G.nodes[i]['attrib1']],
                           *G.nodes[i]['attrib2'], #il trick serve per questa che è già una lista e così le concateni tutte al volo
                           *[G.nodes[i]['attrib3']],
                           *[G.nodes[i]['attrib4']],
                           *[G.nodes[i]['attrib5']],
                           *[G.nodes[i]['attrib6']] ]
                           )                          #aggiunge alla lista il one-hot-encoder (lista) associato all'attributo di quel nodo (activity)
                """
                # <HARDCODED>
                #print(type(G.nodes[i]['attrib2']))
                x1.append([*attr[G.nodes[i]['attribute']],#+list(G.nodes[i]['attrib2']), #non hai capito perché ma questo è ancora "attribute" e non "attrib1"
                           #G.nodes[i]['attrib2'], #*intervetion 1
                           float(G.nodes[i]['attrib3']),
                           float(G.nodes[i]['attrib4']),
                           float(G.nodes[i]['attrib5']),
                           float(G.nodes[i]['ttmotif']),
                           float(G.nodes[i]['polines']),
                           #float(G.nodes[i]['nrchanges']),
                           #float(G.nodes[i]['deltapodd']),
                           *bur[G.nodes[i]['bu']],
                           *plantr[G.nodes[i]['plant']],
                           *itemr[G.nodes[i]['item']],
                           *vendorr[G.nodes[i]['vendor']],
                           *matnrshortr[G.nodes[i]['matnrshort']]
                           ]
                           )                         #aggiunge alla lista il one-hot-encoder (lista) associato all'attributo di quel nodo (activity)
                # <\HARDCODED>
                #x1 = x1+list(G.nodes[i]['attrib2'])
                #print(type(x1))
                #print(x1)
            """
            print(x1)
            print(len(x1))
            """
            x = torch.tensor(x1, dtype=torch.float)
            """
            print("a")
            print(x)
            """
            adj = nx.to_scipy_sparse_array(G)                          #prende la matrice di adiacenza del sottografo
            adj = adj.tocoo()
            row = torch.from_numpy(adj.row.astype(np.int64)).to(torch.long)
            col = torch.from_numpy(adj.col.astype(np.int64)).to(torch.long)
            edge_index = torch.stack([row, col], dim=0)    
            #one value as target for the subgraph 
            #double check if G.graph['target_std'] is the target value                      #crea un vettore contenente gli archi del sottografo
            #it's e.g. this: tensor([11]) so it's just the target value !
            
            y_std = torch.tensor([G.graph['target_std']])             #assegna il valore numerico all'attività da predirre per quel sottografo secondo logica std
            
            #CHANGED!!!
            caseid=G.graph['caseid']
            #NOT NEEDED
            y_par = torch.tensor([target_par[G.graph['target_par']]])             #assegna il valore numerico all'attività da predirre per quel sottografo secondo logica par

            #print(y_par)
 
            #x=tensore attributi nodi sottografo corrente, 
            #edge_index=descrive collegamenti tra nodi, 
            #y=tensore attività da predirre (etichetta) 
            #y_par=tensore attività parallele predicibili (etichetta)
            
            #MIGHT NEED TO REMOVE Y_PAR HERE AS WELL
            #data = Data(x=x, edge_index=edge_index, y=y_std,y_par=y_par,idc=caseid)          #inserisce queste informazioni nella struttura dati utilizzata da pytorch_geometric per gli elementi del dataset
            data = Data(x=x, edge_index=edge_index, y=y_par,idc=caseid)          #inserisce queste informazioni nella struttura dati utilizzata da pytorch_geometric per gli elementi del dataset

            data_list.append(data)                                                #crea una lista contenente gli elementi del dataset
 
        # print("oh")
        # print(data_list)
        data, slices = self.collate(data_list)
        '''
        
        print(data.y)
        print('-------------------------------------')
        print(data.x)
        
        '''
        torch.save((data, slices), self.processed_paths[0])                       #salva il dataset

"""Bloco di codice che monta il drive all'interno del filesystem di colab e avvia la creazione del dataset richiamando il costruttore del dataset"""

import torch_geometric.datasets


import os

PATH='./dataset/'

# file=PATH+'/processed/'+file_name+'.pt'
# if os.path.isfile(file):
#   os.remove(file) 
# G = TraceDataset()
# print("done")

#first graph for all cases, for some reason missing my final graph #supposed to be 458 instead of 457 graphs
#then subgraphs for all prefixes>2 size 
create_graph()